# 数组

- [数组](#数组)
  * [两数之和](#两数之和)
    + [暴力解法](#暴力解法)
    + [Hash Map](#hash-map)
  * [最小差值I](#最小差值i)
  * [删除数组中的重复项](#删除数组中的重复项)
    + [贪心算法](#贪心算法)
    + [双指针](#双指针)
  * [旋转数组](#旋转数组)
  * [存在重复元素](#存在重复元素)
  * [只出现一次的数字](#只出现一次的数字)
  * [两个数组的交集II](#两个数组的交集II)
  * [加一](#加一)
  * [移动零](#移动零)
  * [有效的数独](#有效的数独)
  * [旋转图像](#旋转图像)

## 两数之和

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum

### 暴力解法

```python
def twoSum(nums, target):
	for i in range(len(nums)):
		t = target - nums[i]
		for j in range(i+1, len(nums)):
			if t == nums[j]: return [i, j]
```

执行用时1468ms。

因为不需要全部查询整个数组，因此只需要拿出数组的一部分进行查询即可，执行时间提高显著。

```Python
def twoSum(nums, target):
    lens = len(nums)
    for i in range(1, lens):
        t = target - nums[i]
        s = nums[:i]
        if t in s: return [s.index(t), i]
```

执行用时348ms。

### Hash Map

使用哈希表加速查询时间。

```python
def twoSum(self, nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        t = target - num
        if t in hashmap: return [hashmap[t], i]
        else: hashmap[num] = i
```

执行用时20ms。

## 最小差值I

给你一个整数数组nums，和一个整数k。

在一个操作中，您可以选择```0 <= i < nums.length```的任何索引i。将nums[i]改为nums[i]+x，其中x是一个范围为[-k,k]的整数。对于每个索引i，最多只能应用一次此操作。

nums的分数是nums中最大和最小元素的差值。

在对nums中的每个索引最多应用一次上述操作后，返回nums的最低分数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/smallest-range-i

```python
def smallestRangeI(nums, k):
    maxe = max(nums)
    mine = min(nums)

    ans = maxe - mine - 2*k
    
    if ans > 0: return ans
    else: return 0
```

## 删除数组中的重复项

给你一个升序排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有k个元素，那么nums的前k个元素应该保存最终结果。

将最终结果插入nums的前k个位置后返回k。

不要使用额外的空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。

链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/
来源：力扣（LeetCode）

### 贪心算法



```python
def removeDuplicates(nums):
    lens = len(nums)
    for i in range(lens-1, 0, -1):
        if nums[i] == nums[i-1]: 
            lens -= 1
            del nums[i]
    return lens
```

执行时间24ms。

### 双指针

## 旋转数组


给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/

```python
def rotate(self, nums, k):
    k %= len(nums)
    items = nums[:-k]
    nums[:-k] = []
    nums.extend(items)
    return nums
```

## 存在重复元素

给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/

```python
def containsDuplicate(self, nums):
    hashmap = {}
    for i, e in enumerate(nums):
        if e in hashmap: return True
        hashmap[e] = i
    return False
```

## 只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？


来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/

```python
def singleNumber(self, nums):
    ans = 0
    for i in nums: ans ^= i
    return ans
```

## 两个数组的交集II

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/

### 暴力

```python
def intersect(self, nums1, nums2):
    nums1.sort()
    nums2.sort()

    i, j = 0, 0
    ans = []
    while(i < len(nums1) and j < len(nums2)):
        if nums1[i] == nums2[j]: 
            ans.append(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]: i += 1
        else: j += 1
    
    return ans
```

### Hash Map

```python
def intersect(self, nums1, nums2):
    ## hash map
    hashmap = {}
    ans = []

    for i in range(len(nums1)):
        if nums1[i] in hashmap: hashmap[nums1[i]] += 1
        else: hashmap[nums1[i]] = 1

    for i in range(len(nums2)):
        if nums2[i] in hashmap and hashmap[nums2[i]] != 0: 
            hashmap[nums2[i]] -= 1
            ans.append(nums2[i])
    
    return ans
 ```
 
## 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/

```python
def plusOne(self, digits):
    for i in range(len(digits)-1, -1, -1):
        if digits[i] != 9:
            digits[i] += 1
            return digits
        else: digits[i] = 0
    digits.insert(0, 1)
    return digits
```

## 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。


来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/

```python
def moveZeroes(self, nums):
    for i in xrange(len(nums)-1, -1, -1):
        if nums[i] == 0:
            del nums[i]
            nums.append(0)
```


## 有效的数独

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。


来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/


```python
def isValidSudoku(self, board):
    row = [[0 for i in xrange(10)] for j in xrange(9)]
    col = [[0 for i in xrange(10)] for j in xrange(9)]
    cell = [[0 for i in xrange(10)] for j in xrange(9)]

    for i in xrange(9):
        for j in xrange(9):
            if board[i][j] == '.': continue
            if row[i][int(board[i][j])] or col[j][int(board[i][j])] \
            or cell[int(floor(i/3) * 3 + floor(j/3))][int(board[i][j])]: return False 
            row[i][int(board[i][j])] = 1
            col[j][int(board[i][j])] = 1
            cell[int(floor(i/3) * 3 + floor(j/3))][int(board[i][j])] = 1
    
    return True
```

## 旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。



来源：力扣 (LeetCode)
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/


```python
def rotate(self, matrix):
    matrix[:] =[list(tup)[::-1] for tup in zip(*matrix)]
```

### 先翻转再对角线对称

```python
    def rotate(self, matrix):   
        matrix.reverse()
        # print(matrix)
        for i in range(len(matrix)):
            for j in range(0, i):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

